---
title: "Ch5.3_20200617"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 5.3.4 switch

```{r}
library(lubridate)
library(stringr)
library(purrr)  #map
library(magrittr)  #pipe
```

另一種條件式執行常用在condition種類煩雜或要全部以「是/否」問句來切出所有互斥condition情境不容易設計時。

condition改成用文字描述，即conditionExpression。

不同conditionExpression與對應body內容改成使用一對對的:

"conditionExpression文字"={body 內容} 的name=value pair


```{r}
switch(實現的conditionExpression,
       "conditionExpression1"= {    },
       "conditionExpression2"= {    },
       :
       :
       "conditionExpressionN"= {    },
       {    })
```


Mathematical function

f(n)={n/2       if n is even
      −(n+1)/2  if n is odd

```{r}
n<- 540

conditionExpression_outcome=
  ifelse(n %% 2==0, "even", "odd") 

switch(
  conditionExpression_outcome,
  "even"={fvalue <- n/2}, # 偶數
  "odd"=fvalue <- -(n+1)/2, # 奇數；只有一行指令可省略{}
  warning("n要整數喔")  
)

print(fvalue)
```


ifelse(test, yes, no)是超級好用/常用的函數：

test: class logical. 測試條件的結果

yes: 結果為T 時你希望的回傳值

no: 結果為F 時你希望的回傳值


```{r}
grades <- c(52, 77, 59, 88, 90)

ifelse(grades >= 60, "及格", "不及格")
```



在R裡{...}（大括號, brace）：

若只有一行指令則{}符號可省略。

依照上一個特性，function(...){....}的body若只有一行指令可省略{...}改寫成function(...) ..., 只是要小心body … 要接在function(...)之後不可換行。


```{r}
miniFun <- function(){
  lubridate::now()
}
miniFun()
```

```{r}
miniFun2 <- function() lubridate::now()
miniFun2()
```

若最後一個被執行的指令會產生print在螢幕的效果，則可以用{...}->或<-{...}將這print的值存出來。

```{r}
result <- 
  {
    x <- 2
    y <- 3
    x**y+15
  }
print(result)
```

```{r}
result2 <-
  {
    x <- 2
    y <- 3
    if(x< 3){
      warning("x值太小")
    } else {
      x**y+15
    }
  }
print(result2)
```


依照上一個特性，function(...){....}的body若最後一個「被執行」的指令是會印在螢幕的值，如該值要當回傳值可以不用return(...)就可以產生值回傳效果。

```{r}
myFun <- function(x,y){
  return(x**y+15)
}

# 等同於
myFun2 <- function(x,y){
  x**y+15
}

myFun(5,3) -> outcome
myFun2(5,3) -> outcome2
print(outcome)
print(outcome2)
```







